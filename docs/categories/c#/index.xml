<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C# on Code experiments</title>
    <link>https://elleryq.github.io/code-experiments/categories/c#/</link>
    <description>Recent content in C# on Code experiments</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Thu, 26 Feb 2015 08:34:00 +0800</lastBuildDate>
    
	<atom:link href="https://elleryq.github.io/code-experiments/categories/c#/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C# template method and type constraint</title>
      <link>https://elleryq.github.io/code-experiments/posts/2015-02-26-c-template-method-and-type-constraint/</link>
      <pubDate>Thu, 26 Feb 2015 08:34:00 +0800</pubDate>
      
      <guid>https://elleryq.github.io/code-experiments/posts/2015-02-26-c-template-method-and-type-constraint/</guid>
      <description>在 linqpad 裡試著，記得先選為 c# program，再貼 code
void Main() { /* // show error run(20); run(&amp;quot;Hello world&amp;quot;); */ run(new Dictionary&amp;lt;string, string&amp;gt;()); } // Define other methods and classes here // Add type constraint for run() // allow only IDictionary void run&amp;lt;T&amp;gt;(T x) where T: IDictionary { Console.WriteLine(typeof(T).ToString()); }  </description>
    </item>
    
    <item>
      <title>C# Lazy</title>
      <link>https://elleryq.github.io/code-experiments/posts/2014-09-03-c-lazy/</link>
      <pubDate>Wed, 03 Sep 2014 10:25:00 +0800</pubDate>
      
      <guid>https://elleryq.github.io/code-experiments/posts/2014-09-03-c-lazy/</guid>
      <description>.Net framework 4 以後多了一個 Lazy，顧名思義是做 Lazy initialization 用的，有真正需要的時候，它才去賦值。
// Run with LINQPad // Please specify &amp;quot;Language&amp;quot; to &amp;quot;C# Program&amp;quot; void Main() { var t = new Lazy&amp;lt;int&amp;gt;(getDefaultInteger); if(!t.IsValueCreated) { Console.WriteLine(&amp;quot;Not yet.&amp;quot;); } Console.WriteLine(t.Value.ToString()); } // Define other methods and classes here int getDefaultInteger() { return 20; }  執行結果會先印出 &amp;ldquo;Not yet.&amp;rdquo; 才印出 20，當呼叫 Value 時，才真正取得值。</description>
    </item>
    
    <item>
      <title>C# 練習：仿 Java Lambda</title>
      <link>https://elleryq.github.io/code-experiments/posts/2014-08-13-c-java-like-lambda-1/</link>
      <pubDate>Wed, 13 Aug 2014 03:03:00 +0800</pubDate>
      
      <guid>https://elleryq.github.io/code-experiments/posts/2014-08-13-c-java-like-lambda-1/</guid>
      <description>C# 從一開始仿 Java，到後來，語法上的發展已經超越 Java，所以現在反而是 Java 仿 C# 與其他語言。最近的 Java 8 在講的 Lambda ，早在 C# 2.0 時，就已經有了雛型，到了 C# 3.0 則已經發展成熟。
就拿這篇 認識 Lambda/Closure（1）從 JavaScript 的函式物件談起 by caterpillar | CodeData 裡的例子來改寫：
// lambda1.cs // How to build: // Linux: dmcs /t:exe lambda1.cs // Windows: csc /t:exe lambda1.cs using System; using System.Collections.Generic; public class DelegatePractice { public static void Main(string[] args) { new List&amp;lt;string&amp;gt;( new string[] {&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;} ).ForEach(delegate(string s) { Console.</description>
    </item>
    
    <item>
      <title>C# about dynamic ExpandoObject member function</title>
      <link>https://elleryq.github.io/code-experiments/posts/2014-07-22-c-about-dynamic-expandoobject-member-function/</link>
      <pubDate>Tue, 22 Jul 2014 09:48:00 +0800</pubDate>
      
      <guid>https://elleryq.github.io/code-experiments/posts/2014-07-22-c-about-dynamic-expandoobject-member-function/</guid>
      <description>由於 ExpandoObject 自身的能力，增加屬性非常簡單。但如果要增加一個 member function，該怎麼做？這可以透過 Func 或 Action 來達成。
List&amp;lt;dynamic&amp;gt; userlist = new List&amp;lt;dynamic&amp;gt;(); // 利用 currying 來模擬類似 python 的 foo(self, x, y...) // C++ 的 this 其實跟 python 一樣，但是 this 不需要明確的寫出來，這部分是編譯器幫忙做掉 // 在 C# 裡，看來是沒辦法，所以在設置 member function 時，就先把 instance 傳進 toString， // 讓 toString 傳回另外一個新 function Func&amp;lt;dynamic, Func&amp;lt;string&amp;gt; &amp;gt; toString = delegate(dynamic user) { return new Func&amp;lt;string&amp;gt; (() =&amp;gt; String.Format(&amp;quot;User: {0} Age: {1}&amp;quot;, user.Name, user.age) ); }; for(int i=0; i&amp;lt;100; i++) { dynamic user = new System.</description>
    </item>
    
    <item>
      <title>C# about dynamic ExpandoObject</title>
      <link>https://elleryq.github.io/code-experiments/posts/2014-07-22-c-about-dynamic/</link>
      <pubDate>Tue, 22 Jul 2014 09:24:00 +0800</pubDate>
      
      <guid>https://elleryq.github.io/code-experiments/posts/2014-07-22-c-about-dynamic/</guid>
      <description>讀了 metaprogramming in .net 第一章，才知道 4.0 以後的 dynamic 很強大。
以前 c# 物件的成員，是必須先在類別裡指定好的，現在透過 ExpandoObject 就可以不需要了，直接就可以指定屬性，然後寫 linq 敘述時，就能直接使用。
List&amp;lt;dynamic&amp;gt; list = new List&amp;lt;dynamic&amp;gt;(); for(int i=0; i&amp;lt;100; i++) { dynamic container = new System.Dynamic.ExpandoObject(); container.id = i; container.Name = String.Format(&amp;quot;John{0}&amp;quot;, i); container.age = i+10; list.Add(container); } var query = from obj in list where obj.age&amp;gt;55 select obj; Console.WriteLine(&amp;quot;query.count = {0}&amp;quot;, query.Count());  補充兩個有趣的 library： * Adventures with C# 4.0 dynamic - ExpandoObject, ElasticObject, and a Twitter client in 10 minutes * The Dynamic Sugar Library</description>
    </item>
    
    <item>
      <title>C# 使用 CodeDomProvider 編譯程式</title>
      <link>https://elleryq.github.io/code-experiments/posts/2014-07-18-c-using-the-codedomprovider-compiler/</link>
      <pubDate>Fri, 18 Jul 2014 03:14:00 +0800</pubDate>
      
      <guid>https://elleryq.github.io/code-experiments/posts/2014-07-18-c-using-the-codedomprovider-compiler/</guid>
      <description>也是從 metaprogramming in .net 看來的，一樣是在 ubuntu 12.04 上用 dmcs /t:exe intantiatingCodeProviders.cs 編譯，執行沒問題。書裡說會有找不到 csc.exe 的情況，但至少在 Ubuntu 上是沒看到。
// intantiatingCodeProviders.cs using Microsoft.CSharp; using System.CodeDom.Compiler; using System.Collections.Generic; class IntantiatingCodeProviders { static void Main() { var providerOptions = new Dictionary&amp;lt;string, string&amp;gt;(); providerOptions.Add(&amp;quot;CompilerVersion&amp;quot;, &amp;quot;v4.0&amp;quot;); var csProv = new CSharpCodeProvider(providerOptions); var compilerParameters = new CompilerParameters(new string[] { }); CompilerResults results = csProv.CompileAssemblyFromSource(compilerParameters, @&amp;quot;namespace V3Features { class Program { static void Main() { var name = &amp;quot;&amp;quot;Kevin&amp;quot;&amp;quot;; System.</description>
    </item>
    
    <item>
      <title>C# CodeDom Provider</title>
      <link>https://elleryq.github.io/code-experiments/posts/2014-07-18-c-codedom/</link>
      <pubDate>Fri, 18 Jul 2014 03:06:00 +0800</pubDate>
      
      <guid>https://elleryq.github.io/code-experiments/posts/2014-07-18-c-codedom/</guid>
      <description>看 metaprogramming in .net 時，看到的範例，可以列出 CodeDom Provider：
using System; using System.CodeDom; public class Practice { public static void Main(string[] args) { foreach (System.CodeDom.Compiler.CompilerInfo ci in System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo()) { foreach (string language in ci.GetLanguages()) System.Console.Write(&amp;quot;{0} &amp;quot;, language); System.Console.WriteLine(); } } }  Ubuntu 12.04 上的結果，如果有裝 IronPython 之類的，或是有自訂會更多。
c# cs csharp vb vbs visualbasic vbscript js jscript javascript vj# vjs vjsharp c++ mc cpp  </description>
    </item>
    
    <item>
      <title>C# currying</title>
      <link>https://elleryq.github.io/code-experiments/posts/2014-07-01-c-currying/</link>
      <pubDate>Tue, 01 Jul 2014 07:26:00 +0800</pubDate>
      
      <guid>https://elleryq.github.io/code-experiments/posts/2014-07-01-c-currying/</guid>
      <description>順手試試看。 C# 的 Func 比較囉唆一點，寫完你會很懷念 javascript 或 python 之類的語言。第一個參數是傳給函數的參數，第二個參數是傳回的參數。所以要 Currying，就是把第二個參數再設為 Func 就可以。Func 不只有一個參數的版本，也有兩個、三個&amp;hellip;等等的版本，但不是無限的，有一定限度，最多到 16 個，也就是 Func&amp;lt;T1, T2, T3&amp;hellip;., T16, TResult&amp;gt; 。
using System; public class Anonymous { public static void Main() { Func&amp;lt;string, Func&amp;lt;string, int&amp;gt; &amp;gt; say = delegate(string greeting) { Func&amp;lt;string, int&amp;gt; foo = delegate(string name) { Console.WriteLine(&amp;quot;{0} {1}&amp;quot;, greeting, name); return 0; }; return foo; }; Func&amp;lt;string, int&amp;gt; hello = say(&amp;quot;Hello&amp;quot;); hello(&amp;quot;John&amp;quot;); } }  </description>
    </item>
    
  </channel>
</rss>